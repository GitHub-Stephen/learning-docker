---
outline: deep
---

## Docker中的网络

&emsp;&emsp;**容器网络**指的是容器间的网络通信，或者与其他负载组件的网络通信。

&emsp;&emsp;容器本身有默认的网络设置，提供出口（访问外部网络）的网络连接。容器信息中，不包含他们连接的是什么类型的网络，或者它们自身的节点是不是 Docker 集群。不过容器中包含了一些基本信息如：IP 地址、网关、路由对照表、DNS 服务等其他详情。

### 自定义网络
&emsp;&emsp;我们可以按照需求设置网络，让多个容器可以互相通信。进行设置之后，容器之间可以通过 IP 地址或者（容器）名称进行连接。

让我们来看一个简单的例子，利用`bridge`网络驱动来启动一个容器：

```shell
# 创建网络
docker network create my-net

# 运行一个自定义网络的容器
docker run --network=my-net -itd --name=container3 busybox
```

#### 驱动

| Driver    | Description                                                              |
| :-------- | :----------------------------------------------------------------------- |
| `bridge`  | 默认网络设置，一般称为“桥接模式”                                               |
| `host`    | 消除容器与宿主机的网络隔离，一般称为“主机模式”      |
| `none`    | 容器与宿主机完全隔离，“无网络”模式       |
| `overlay` | 在多个 Docker 进程之上构建一层网络               |
| `ipvlan`  | IPvlan 网络模式 提供了基于 IPv4 IPv6 的网络设置 |
| `macvlan` | 基于 MAC 地址的网络设置模式                                     |


### 容器网络

&emsp;&emsp;除了自定义网络，您可以直接从一个容器连接到另外一个容器，利用`--network container:<name|id>` 命令行参数来操作。

如果使用了`container:`这种模式，以下的命令行参数则不支持：

- `--add-host`
- `--hostname`
- `--dns`
- `--dns-search`
- `--dns-option`
- `--mac-address`
- `--publish`
- `--publish-all`
- `--expose`

我们来看一个简单的例子：

```shell
docker run -d --name redis example/redis --bind 127.0.0.1

docker run --rm -it --network container:redis example/redis-cli -h 127.0.0.1
```

首先是启动一个 redis 服务的容器，并绑定`localhost`; 然后通过命令行`redis-cli`来连接`localhost`的 redis 服务。

### 发布（暴露）端口

&emsp;&emsp;在默认情况下，如果我们是使用`docker create`或者`docker run`来创建或启动容器，容器不会对外暴露任何端口。利用`--publish`或者`-p`标识来将（容器中）服务的端口暴露出去。这实际是在主机建立了一个防火墙规则，把容器的端口映射（关联到）到宿主机上。以下是一些示例：

| Flag value                      | Description                                                                                                                                             |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `-p 8080:80`                    | 通过 TCP 的方式，映射宿主机 `8080` 端口到容器中的 `80` 端口。                                                                                    |
| `-p 192.168.1.100:8080:80`      | 通过 TCP 的方式，映射宿主机的 IP `192.168.1.100`、`8080` 端口到容器中的 `80` 端口中。                                                                                        |
| `-p 8080:80/udp`                | 通过 UDP 的方式，映射宿主机 `8080` 端口到容器中的 `80` 端口。                                                                                   |
| `-p 8080:80/tcp -p 8080:80/udp` | 通过 TCP 的方式，映射宿主机 `8080` 端口到容器中的 `80` 端口, 同时通过 UDP 的方式，映射宿主机 `8080` 端口到容器中的 `80` 端口。
|


> 💡 重要提示
>
> 暴露端口实际上是不安全的。因为你暴露的不单单是容器的，同时也是暴露到互联网上。
>
> 如果暴露端口时，包含了 IP 地址（127.0.0.1），那么只有宿主机能访问容器的这个端口，如：
>
> ```shell
> docker run -p 127.0.0.1:8080:80 nginx
> ```
> 

如果您想使两个容器间的网络想通，您无需暴露任何端口。您可以利用`bridge network`(桥接网络)来进行内部连接。

### IP address 和 hostname

默认情况下，容器会从连接的网络中获得一个 IP 地址。 Docker 守护进程会为容器动态进行子网划分和 IP 地址分配。每一个容器的网络，都有其默认子网掩码和网关。

当启动一个容器时，我们可以使用`--network`标识来连接指定的网络。还可以利用`docker network connect`命令来连接额外的网络。再以上两种情况下，可以使用`--ip`或者`--ip6`标识来显式地指定 IP 地址。

为了方便记忆，还可以使用`--hostname`来标识一个 hostname（主机名称）。当使用`docker network connect`命令连接时，可以使用`--alias`标识来指定网络进行连接。

### DNS 服务

在默认情况下，容器是使用与宿主机相同的 DNS 服务。不过可以通过`--dns`标识来重写。

默认情况下，容器是继承了编写在 `/etc/resolv.conf` 文件中DNS的设置。容器是连接了一个默认的网桥


