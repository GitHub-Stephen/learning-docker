import{_ as a,c as o,a0 as i,G as l,w as n,B as t,o as p,a as h}from"./chunks/framework.nOBYma8F.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"Persistence.md","filePath":"Persistence.md"}'),d={name:"Persistence.md"};function k(c,s,r,u,m,g){const e=t("center");return p(),o("div",null,[s[1]||(s[1]=i(`<h2 id="docker存储" tabindex="-1">Docker存储 <a class="header-anchor" href="#docker存储" aria-label="Permalink to &quot;Docker存储&quot;">​</a></h2><p>启动容器之后，所有文件默认都存在于容器中，那么我们则需要注意一下几点：</p><ul><li>如果容器被移除了，那么文件也将随之消失，在<strong>容器外</strong>的其他进程如果想获取<strong>容器内</strong>的文件，也比较困难</li><li>一个可写的容器层是紧密地与主机（也称<code>宿主机</code>）绑在一起，我们也很难把容器内的数据移动到其他地方</li><li>将数据写入容器时，我们需要<code>store driver</code> （存储驱动软件）来管理，它是基于 Linux 内核的一个文件系统的抽象实现，不过这个实现却会造成一些性能损耗</li></ul><p>为了解决 Docker 在宿主机文件存储问题，Docker提供了两种方式：有两种方式 <code>volumes</code> 和 <code>bind mounts</code>.</p><p>借助官网一张图来看看这两种数据存储方式的区别： <img src="https://cdn.jsdelivr.net/gh/Github-Stephen/blogPic/springboot/20240121090140.png" alt="20240121090140"></p><p><code>Volumes</code>模式： 实际存储在<code>宿主机</code>的文件系统中，只不过这个（文件）区域是被 Docker 所管理，我们通常可以在<code>/var/lib/docker/volumes/</code>（下称“Docker存储区”） 里查看得到;</p><p><code>Bind mounts</code> 模式：可以存储在<code>宿主机</code>（Docker 进程所在的主机）的任意位置， 它或许是一个重要文件，或者是一个目录。<code>宿主机</code>上的非 Docker 进程或者是在容器内可随意修改；</p><p><code>temfs</code> mount模式： 只存储在<code>宿主机</code>的内存中，并且永远不会持久化到文件系统中；</p><p>清晰地了解每个模式的作用，才能在工作中运用自如，以上的模式，我们可以利用<code>-v</code>或者<code>--volume</code>来标识，不过这两个命令有轻微的区别，对于<code>tmpfs</code>模式，可以使用<code>--tmpfs</code>标识。不过通常使用<code>--mount</code>标识来挂载容器与宿主机之间的内容，这样更清晰和容易记忆。</p><h3 id="volume" tabindex="-1">VOLUME <a class="header-anchor" href="#volume" aria-label="Permalink to &quot;VOLUME&quot;">​</a></h3><p>  <code>volume</code>由 Docker 创建和管理的，我们可以是用<code>docker volume create</code>命令来创建一个<code>volume</code>，或者 Docker 会随着容器、服务的创建而新建一个<code>volume</code>.</p><p>  当我们创建一个<code>volume</code>时，实际这个<code>volume</code>是存储在Docker所在的宿主机上一个目录中，上一小节已经讲过（Docker存储区）。当我们把这个<code>volume</code>挂载到容器中时，它的运作则有点像<code>bind mounts</code>，区别在于，<code>volume</code>是由 Docker 管理并独立于宿主机（通常部署的是 Linux 系统）的核心功能.</p><p>  一个<code>volume</code>可以同时挂载到多个容器中。匿名的<code>volume</code>会获得一个随机且唯一的名称。如果您想删除<code>volume</code>，需要显式使用<code>--rm</code>命令，否则<code>volume</code>将会一直存在与 Docker 所管理的区域中（Docker存储区）。</p><p>  <code>volume</code>也支持<code>volume drivers</code>，这样我们可以把文件存储在远程服务器或者云存储等其他介质，这个后续我们在示例中再介绍。</p><h3 id="bind-mounts" tabindex="-1">Bind mounts <a class="header-anchor" href="#bind-mounts" aria-label="Permalink to &quot;Bind mounts&quot;">​</a></h3><p>  <code>Bind mounts</code>相对于<code>volume</code>有一些限制。当你使用<code>bind mount</code>时，实际就是将<code>宿主机</code>的某个文件、目录挂载进容器而已，容器是指向了<code>宿主机</code>的完整路径，如 <code>/home/app/myfile:/docker/myfile</code>（宿主机路径：容器内路径）。<code>bind mount</code>在挂载时，Docker 所在区域 （Docker存储区）无需创建该目录，后台进程将会自动创建（相当于在 Linux 系统执行了 <code>mkdir -p /home/app</code>）。<code>Bind mounts</code>运行速度快，但是其依赖<code>宿主机</code>特定的文件目录结构。建议在开发新的容器程序时，优先使用<code>named volumes</code>（具名 <code>volume</code>）。而且我们也无法通过<code>Docker CLI commonds</code>来管理<code>bind mounts</code>所操作的目录。</p><p>  注意：<code>Bind mounts</code>默认具有<code>宿主机</code>的写入权限！ 这可能会带来一些安全的问题，因为容器可直接操作<code>宿主机</code>的文件系统（创建、更改、删除），或者<code>宿主机</code>上的其他非 Docker 进程，也可以破坏被<code>bind mount</code>的文件、目录。</p><p>以上介绍了一些 Docker 的存储方式，那我们可以来看看这些存储方式的最佳的应用场景：</p><h2 id="volumes使用场景" tabindex="-1">Volumes使用场景 <a class="header-anchor" href="#volumes使用场景" aria-label="Permalink to &quot;Volumes使用场景&quot;">​</a></h2><ul><li><p>多个容器共享数据，你无需手动创建挂载的内容，Docker 将会按照你的配置自动创建挂载关系。即使容器停止、删除，挂载的数据仍存在，如果需要删除挂载的内容，你可以指定命令删除(docker volume rm)</p></li><li><p>如果当 Docker 主机没有给定目录或者文件结构时，Volumes 可将 Docker 主机的配置和容器运行时进行解耦</p></li><li><p>让你想讲数据存储在云供应商时，可选择 Volumes 模式</p></li><li><p>当你准备备份、恢复、或者迁移数据到其他机器时，volumes 可能是很好的选择，你只要停止容器，然后进入到指定目录（Docker 存储区: <code>/var/lib/docker/volumes/&lt;volume-name&gt;</code>)即可访问得到</p></li><li><p>当你的程序运行在 Docker Desktop（图形化界面管理 Docker 的工具），且需要高性能I/O时，Volumes 通常存储数据是在Linux 虚拟机中，而不是宿主机上，这保证了低延迟和高吞吐的读写</p></li><li><p>让你的程序运行在 Docker Desktop 中且希望保持文件系统的原始的特性时。例如：数据库引擎需要精确地控制磁盘的刷新来确保事务的持久性</p></li></ul><h2 id="bind-mounts使用场景" tabindex="-1">Bind mounts使用场景 <a class="header-anchor" href="#bind-mounts使用场景" aria-label="Permalink to &quot;Bind mounts使用场景&quot;">​</a></h2><ul><li><p>从宿主机共享配置文件到容器内。在默认情况下，这也是 Docker 提供 DNS 解决方案到容器内的方式，实际是将宿主机的<code>/etc/resolv.conf</code>挂载进去容器中</p></li><li><p>在宿主机和容器之间共享源码或者构建包（如 Java程序 打包后的 jar 包）。举个例子：我们可以将Maven中的<code>target/</code>目录挂载进容器，然后每次在宿主机打包（build）时，容器只要获取到读写权限，即可获取到 Maven 的构建包。 如果你是倾向于 Docker 的开发模式（在Docker容器运行服务），那你在定义 Dockerfile的时候，直接把预生产的构建包拷贝到镜像中，则不用依赖于Bind mounts了。</p></li><li><p>当文件、目录结构在宿主机、容器中需要保持一致时，如，宿主机、容器，myConfig 文件都放置于<code>/home/soft/conf</code>目录下。</p></li></ul><br><p>  对比以上的使用场景，我们可以知道，Volumes 和 Bind mounts 有相似之处，都可以理解为宿主机与容器间的数据共享，却又不尽相同（使用场景），那么我们在决策时，应该有什么依据呢？</p><ul><li><p>当你挂载一个空的 volume 进入到容器中已存在的文件或者目录时，容器内的文件、目录，将会<code>复制</code>到这个空的 volume 中；同理，如果你运行一个容器并定义一个不存在的 volume 时，容器将会自动创建，这对于一些具备初始化数据的容器非常有用，依赖于该容器的其他容器，则可以很方便的共享到这些数据</p></li><li><p>当你挂载一个 bind mounts 或非空 volume进入到容器已存在的文件、目录中，容器中的这些文件、目录将会被<code>mount</code>的机制所隐藏；举个例子，当你机器插入 USB 设备且被 Linux 系统识别为<code>/mnt</code>，此时往<code>mnt</code>写入数据，实际是写入了 USB 设备，但是 Linux 系统中实际的<code>mnt</code>并不会丢失，而是被隐藏（无法访问）了。当USB被拔出时，这个<code>mnt</code>目录则会重新恢复。</p></li></ul><h2 id="volumes" tabindex="-1">Volumes <a class="header-anchor" href="#volumes" aria-label="Permalink to &quot;Volumes&quot;">​</a></h2><p>Volumes 是 Docker 容器中良好的存储数据的机制。相对于 bind mounts 需要依赖目录结构或宿主机的操作系统，Volumes 是完全由 Docker管理的。对比来说，Volumes 有以下优势：</p><ul><li>Volumes 容易备份和迁移；</li><li>可以使用 Docker CLI 命令行或者 Docker API 来管理 Volumes；</li><li>Volumes 可以很好地运行在 Windows、Linux 的容器中；</li><li>Volumes 可以安全地与其他容器共享数据（因其在 Docker 管理之下，无法破坏宿主机文件系统）；</li><li>Volumes 驱动程序，可以让我们存储数据到远程机器、云提供商，加密存储内容，或者加入其他功能；</li><li>一个新的 Volumes 可以从其他容器中，获得预加载的内容；</li><li>在 Mac、Windows 的 Docker Desktop 中，Volumes 相对于 bind mounts 拥有更好的性能;</li></ul><h3 id="选择-v-或者-mount标识" tabindex="-1">选择 <code>-v</code> 或者 <code>-mount</code>标识 <a class="header-anchor" href="#选择-v-或者-mount标识" aria-label="Permalink to &quot;选择 \`-v\` 或者 \`-mount\`标识&quot;">​</a></h3><p>在使用 Volumes 之前，我们有必要了解下以上命令的区别：</p><ul><li><p><code>-v</code>和<code>--volume</code>：由3个参数组成，并且中间以(<code>:</code>)间隔开，参数排序必须是正确的，但是每个参数的含义确不是特别明显，我们来阐述一下；</p><ul><li><p>对于具名 volumes，第1个参数是 volume 的名称，这个名字是宿主机内唯一的。对于匿名 volumes 第一个字段则可以省略；（具名 volume 和匿名 volume 通常可以从字面理解，前者有名称，方便记忆，后者随机名称，沿用 Docker 生成的唯一名字）</p></li><li><p>第2个参数则表示哪个目录需要挂载到容器中</p></li><li><p>第3个参数是可选的，主要是一些更细化的操作，后续使用中，我们可继续讲解；</p></li></ul></li><li><p><code>--mount</code>：由多组<code>key:value</code>组成，以(<code>,</code>)分割，<code>--mount</code>相对于<code>-v</code>和<code>-volume</code>来说，会比较冗长，但是命令中<code>key</code>的顺序并没有要求，且每个<code>key</code>的含义都比较清晰</p><ul><li><p><code>type</code>表示挂载的类型，可以是<code>bind</code>、<code>volume</code>、<code>tmpfs</code>，本章讨论的是 volumes，以<code>volume</code>为主</p></li><li><p><code>source</code>相对于 具名 volumes，则是表示 volume 的名称，对于匿名 volume，这个 key 则可以省略。<code>source</code>也可以简写为<code>src</code></p></li><li><p><code>destination</code>则是表示哪个目录挂载进容器。也可以简写为<code>dst</code>或者<code>target</code></p></li><li><p><code>readonly</code>如果被设置了，对于bind mount 则是相当于挂载进容器的目录，只有读取权限。可简写为<code>ro</code></p></li><li><p><code>volume-opt</code>选项可被定义多次，以 key-value 的方式组成</p></li></ul></li></ul><h3 id="创建和管理volumes" tabindex="-1">创建和管理volumes <a class="header-anchor" href="#创建和管理volumes" aria-label="Permalink to &quot;创建和管理volumes&quot;">​</a></h3><p>与 bind mount 不同的是，你可以在容器管理区域外，直接创建 volumes</p><p>我们尝试创建一个 volume:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker volume create my-vol</span></span></code></pre></div><p>（备注：<code>#</code>符号是Linux命令自带的，在输入时，请不要加入哦）</p><p>查看创建的 volume:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker volume ls</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     my-vol</span></span></code></pre></div><p>检查 volume:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker volume inspect my-vol</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;CreatedAt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2023-11-22T16:21:27+08:00&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Driver&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;local&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Labels&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: null,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Mountpoint&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my-vol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Options&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: null,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &quot;Scope&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;local&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>删除一个 volume:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker volume rm my-vol</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">my-vol</span></span></code></pre></div><h3 id="带-volume-启动容器" tabindex="-1">带 volume 启动容器 <a class="header-anchor" href="#带-volume-启动容器" aria-label="Permalink to &quot;带 volume 启动容器&quot;">​</a></h3><p>如果你启动容器时 volume 不存在，Docker 会为您自动创建。我们启动一个<code>nginx</code>来体验下：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker run -d </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --name devtest </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --mount source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">myvol2,</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/add</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx:latest</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beb26e026cda87cba28da416ac8357b3aff42b547f6939b6d84cef9d3694fea8</span></span></code></pre></div><p>(备注: 在命令行结尾输入<code>\\</code>后按回车键，命令光标会自动换行，可继续输入)</p><p>我们来检查（docker inspect）下容器的情况：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker inspect devtest</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;Mounts&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Type&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;volume&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Name&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myvol2&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Source&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/var/lib/docker/volumes/myvol2/_data&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Destination&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/add&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Driver&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;local&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Mode&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;z&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;RW&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">         &quot;Propagation&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>容器信息比较多，我们目前只要关注<code>Mount</code>的信息即可，从以上信息，我们可以得知挂载类型为<code>volume</code>，挂载的 Source（来源）和 Destination（目标），<code>RW</code>为<code>true</code> 表示容器具备读写权限。</p><p>我们尝试停止并删除容器：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker container stop devtest</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker container rm devtest</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]# docker volume ls</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     myvol2</span></span></code></pre></div><p>我们也验证了，即使删除了容器，volume 仍然存在，除非主动删除。</p><h3 id="在-docker-compose-中使用-volume" tabindex="-1">在 Docker Compose 中使用 volume <a class="header-anchor" href="#在-docker-compose-中使用-volume" aria-label="Permalink to &quot;在 Docker Compose 中使用 volume&quot;">​</a></h3><p>(待写完docker-compose后补充)</p><h3 id="在不同机器中共享数据" tabindex="-1">在不同机器中共享数据 <a class="header-anchor" href="#在不同机器中共享数据" aria-label="Permalink to &quot;在不同机器中共享数据&quot;">​</a></h3><p>当我们在部署具备容错机制的应用时，我们一般会配置多台从机（主从架构）来读取一个相同的文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Github-Stephen/blogPic/springboot/20240201085556.png" alt="20240201085556"></p>`,57)),l(e,null,{default:n(()=>s[0]||(s[0]=[h("引用自Docker官网")])),_:1}),s[2]||(s[2]=i('<p>从上图可以看到，每台机器(node)部署了一些从服务（service-replica），运行在docker上，共享着相同的数据。</p><p>我们有多种方式达成<strong>多个机器共享数据</strong>的方式，如：</p><ul><li>直接在应用程序中加入逻辑，存储数据到云对象存储如 Amazon S3 或者 minio等；</li><li>创建一个带驱动程序(driver)的 volume, 以此来支持读写外部文件如 <a href="https://linux.vbird.org/linux_server/centos6/0330nfs.php#What_NFS_NFS" target="_blank" rel="noreferrer">NFS</a> 或 Amazon S3；</li></ul><p>Volume Driver 具备抽象性，也就是你无需关心底层存储如何运作，只需关心存储的（业务）逻辑即可。</p><h3 id="使用-volume-driver" tabindex="-1">使用 volume driver <a class="header-anchor" href="#使用-volume-driver" aria-label="Permalink to &quot;使用 volume driver&quot;">​</a></h3><p>（进阶用法，后续介绍）</p><h3 id="备份、恢复、迁移数据" tabindex="-1">备份、恢复、迁移数据 <a class="header-anchor" href="#备份、恢复、迁移数据" aria-label="Permalink to &quot;备份、恢复、迁移数据&quot;">​</a></h3><p>我们可以使用<code>--volumes-from</code>来创建一个绑定具体 volume 的容器，</p><h4 id="备份" tabindex="-1">备份 <a class="header-anchor" href="#备份" aria-label="Permalink to &quot;备份&quot;">​</a></h4><p>我们启动一个新的容器：</p><p>(docker run -v启动失败问题：<a href="https://www.cnblogs.com/yangcl-blogs/p/10559839.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/yangcl-blogs/p/10559839.html</a>)</p><h3 id="删除-volumes" tabindex="-1">删除 volumes <a class="header-anchor" href="#删除-volumes" aria-label="Permalink to &quot;删除 volumes&quot;">​</a></h3><p>我们知道 Docker 中的 volume，是不会随着容器删除而丢失的，对于 具名 Volume 和匿名 volume ，我们需要考虑：</p><ul><li><p>具名 volume 在容器外，有一个指定的来源（docker 管理区域中的文件路径），如： myvol:/container_vol</p></li><li><p>匿名 volume 没有指定的来源，我们可以在删除容器时，<strong>显示地</strong>告知容器删除 volume 如：</p></li></ul><p><code>docker run --rm -v /foo -v new_vol:/bar ubuntu /bin/bash</code>）</p><p>以上命令，是启动容器时，删除容器里面的<code>foo</code>，并自动删除 Docker 引擎管理的对应的匿名 volume，同时新增一个挂载 <code>new_vol:/bar</code></p><h3 id="删除所有-volume" tabindex="-1">删除所有 volume <a class="header-anchor" href="#删除所有-volume" aria-label="Permalink to &quot;删除所有 volume&quot;">​</a></h3><p><code>docker volume prune</code></p><h2 id="bind-mounts-1" tabindex="-1">Bind Mounts <a class="header-anchor" href="#bind-mounts-1" aria-label="Permalink to &quot;Bind Mounts&quot;">​</a></h2><p>Bind mounts 在 Docker 早期就已经存在，相对于 volumes ,它有一定的限制。 在使用 bind mount 时，实际是把宿主机的（绝对路径）目录挂载到容器中。相比之下，如果使用的是 volume ，则是由 Docker 的存储路径来进行挂载映射，存储内容由 Docker 进行管理。</p><p>Docker 将会自动为我们创建文件、目录，即使宿主机不存在挂载的目录。Bind mounts 相对性能较高，但是其依赖宿主机的文件系统，可能会导致您在其他事项（文件权限处理）花费时间。 如果您是开发 Docker 应用的新手，建议使用 具名volume (named volumes)。 另外，Bind mounts 也无法通过 Docker CLI commonds 进行管理。</p><h2 id="选择-v-或者-mounts-标识" tabindex="-1">选择 <code>-v</code> 或者 <code>--mounts</code> 标识 <a class="header-anchor" href="#选择-v-或者-mounts-标识" aria-label="Permalink to &quot;选择 `-v` 或者 `--mounts` 标识&quot;">​</a></h2><p>通常，<code>--mounts</code>会比较清晰且冗长。<code>-v</code>的语法则是将所有选项以参数的形式列出。</p><blockquote><p>💡提示 <br> 对于新手，可能学习<code>--mounts</code>会比较快；对手熟悉 Docker 的开发者，<code>-v</code>则会相对比较熟悉；不过通常建议使用<code>--mounts</code>，因为其相对容易使用。</p></blockquote><p><code>-v</code>和<code>--mount</code>的对比，我们可以参考<a href="https://www.baidu.com" target="_blank" rel="noreferrer">Volume - 选择 <code>-v</code> 或者 <code>--mounts</code> 标识</a>。</p><h2 id="v-和-mounts的不同表现" tabindex="-1"><code>-v</code> 和 <code>--mounts</code>的不同表现 <a class="header-anchor" href="#v-和-mounts的不同表现" aria-label="Permalink to &quot;`-v` 和 `--mounts`的不同表现&quot;">​</a></h2><p>由于<code>-v</code>或<code>--volume</code>在 Docker 早期就已经存在，所以他们的运作模式不会被改变，那么区别是在<code>-v</code>和<code>--mounts</code>上：</p><ul><li><p>如果您使用<code>-v</code>或者<code>--volume</code>去 bind-mount 文件或者目录，（这些文件、目录）并不存在于宿主机上，Docker 会提供一个入口，往往是以创建目录的形式；</p></li><li><p>如果您使用的是<code>--mounts</code>来 bind-mount 文件或者目录，（这些文件、目录）并不存在于宿主机上，Docker <strong>不会</strong> 自动创建文件，目录，而是会抛出一个错误。</p></li></ul><h2 id="使用-bind-mount-的方式来启动一个容器" tabindex="-1">使用 bind mount 的方式来启动一个容器 <a class="header-anchor" href="#使用-bind-mount-的方式来启动一个容器" aria-label="Permalink to &quot;使用 bind mount 的方式来启动一个容器&quot;">​</a></h2><p>我们可以假设一个场景， （在宿主机）有一个源码的目录如<code>source</code>，通过打包后，生成的构建包（如jar）会存放在<code>source/target</code>目录下。我们希望容器中的<code>/app/</code>目录能读取到构建包。</p><h3 id="使用-mount" tabindex="-1">使用<code>--mount</code> <a class="header-anchor" href="#使用-mount" aria-label="Permalink to &quot;使用`--mount`&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost home]# docker run -d   -it   --name devtest   --mount type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bind,</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pwd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)&quot;/target,</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/app</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   nginx:latest</span></span></code></pre></div><p>以上命令，表示挂载方式为 bind mount，<code>source</code>是当前工作目录 $(pwd) 下的 target 目录，容器内目标路径是 /app</p><p>如果 source 目录不存在，则 Docker 将会抛出一个错误：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Error</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> response</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> daemon:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> invalid</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> type</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;bind&quot;:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bind</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> source</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> does</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> not</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exist:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /home/target.</span></span></code></pre></div><p>我们只要在宿主机创建正确的目录(home/target)，再执行<code>--mount</code>即可成功挂载并启动容器。</p><h3 id="使用-v" tabindex="-1">使用<code>-v</code> <a class="header-anchor" href="#使用-v" aria-label="Permalink to &quot;使用`-v`&quot;">​</a></h3><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[root@localhost home]# docker run -d   -it   --name devtest   -v </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pwd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/target:/app   nginx:latest</span></span></code></pre></div><p>与<code>--mount</code>的区别在于，<code>-v</code>会自动创建宿主机的目录。我们可以使用<code>docker inspect devtest</code>查看下挂载情况：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> &quot;Mounts&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        &quot;Type&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;bind&quot;,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        &quot;Source&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/home/target&quot;,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        &quot;Destination&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/app&quot;,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        &quot;Mode&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        &quot;RW&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">,</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        &quot;Propagation&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;rprivate&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span></code></pre></div><h2 id="挂载到容器中非空的目录" tabindex="-1">挂载到容器中非空的目录 <a class="header-anchor" href="#挂载到容器中非空的目录" aria-label="Permalink to &quot;挂载到容器中非空的目录&quot;">​</a></h2><p>如之前章节说明过，挂载到一个非空的目录，那么该目录的内容，将会被<strong>隐藏</strong>。这个<strong>隐藏</strong>的特性，你可以使用同一镜像，来测试不同版本的 Docker 应用。</p>',42))])}const v=a(d,[["render",k]]);export{F as __pageData,v as default};
